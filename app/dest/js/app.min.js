'use strict';

VeeValidate.Validator.extend('containN', {
    getMessage: function getMessage(field) {
        return 'The ' + field + ' contains numeric.';
    },
    validate: function validate(value, args) {
        return !parseInt(value.replace(/\D/g, ''));
    }
});

//upper
Vue.filter('upperCase', function (value) {
    return value.toUpperCase();
});

//lower
Vue.filter('lowerCase', function (value) {
    return value.toLowerCase();
});

//trim
Vue.filter('trim', function (value) {
    return value.trim();
});

//number
Vue.filter('number', function (value) {
    return Number(value);
});

//bool
Vue.filter('bool', function (value) {
    return Boolean(value);
});

//string
Vue.filter('string', function (value) {
    return String(value);
});

//title
Vue.filter('title', function (value) {
    return value.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
});

//replace
Vue.filter('replace', function (value, strWith, strTo) {
    var regex = new RegExp(strWith, 'g');
    return value.replace(regex, strTo);
});

//address
Vue.filter('address', function (value) {
    value = value.replace(' Väg', ' väg');
    value = value.replace(' Lgh', ' lgh');
    value = value.replace(' Allé', ' allé');
    value = value.replace(' Gata', ' gata');
    value = value.replace(' Backe', ' backe');
    value = value.replace(' C/o ', ' c/o ');

    return value;
});

//postalCode
Vue.filter('postalCode', function (value) {
    if (value.match(/[0-9]{5}/)) {
        return value.substr(0, 3) + ' ' + value.substr(3, 2);
    }
    return value;
});

//phoneNumber
Vue.filter('phoneNumber', function (value) {
    var re = /(?:([\d]{1,}?))??(?:([\d]{1,3}?))??(?:([\d]{1,3}?))??(?:([\d]{2}))??([\d]{2})$/;
    return value.replace(/[^0-9]/g, '').replace(re, function (all, a, b, c, d, e) {
        return (a ? "+ " + a + " " : "") + (b ? b + " " : "") + (c ? c + "-" : "") + (d ? d + "-" : "") + e;
    });
});
'use strict';

$(function () {

    var config = {
        errorBagName: 'errors', // change if property conflicts
        fieldsBagName: 'fields',
        delay: 0,
        locale: 'en',
        dictionary: null,
        strict: true,
        classes: true,
        classNames: {
            touched: 'touched', // the control has been blurred
            untouched: 'untouched', // the control hasn't been blurred
            valid: 'valid', // model is valid
            invalid: 'invalid', // model is invalid
            pristine: 'pristine', // control has not been interacted with
            dirty: 'dirty' // control has been interacted with
        },
        events: 'input|blur|submit',
        inject: true,
        validity: false,
        aria: true
    };

    Vue.use(VeeValidate, config);
    // Vue.use(VeeValidate);

    new Vue({
        el: '#root',
        data: {
            contacts: [],
            contact: new Contact(),
            age: [20, 21, 22, 23, 24]
        },
        mounted: function mounted() {
            this.contacts = [new Contact('iuhwef', 'wefwef', 'm', 20), new Contact('efwg', 'fweg', 'f', 22), new Contact('iuhwef', 'hrth', 'm', 24), new Contact('gerrhe', 'rehewrg', 'f', 21), new Contact('sdgsgtwe', 'wegwe', 'f', 22)];
        },

        methods: {
            getContact: function getContact(contact) {
                this.contact = contact;
            },
            addContact: function addContact() {
                if (this.isValid() && !this.contact.empty()) {
                    this.contacts.push(this.contact);
                    this.contact = new Contact();
                }
            },

            reset: function reset() {
                this.contact = new Contact();
                this.$children.map(function (child) {
                    child.$validator.reset();
                });
            },
            isValid: function isValid() {
                this.$children.map(function (child) {
                    child.$validator.validateAll().then(function (response) {
                        return response;
                    }).catch(function (response) {
                        return response;
                    });
                });
            }
        }
    });
});
'use strict';

Vue.component('input-box', {
    template: '<div class="form-group" :class="{\'has-error\': this.fields[name].touched && this.fields[name].invalid, \'has-success\': this.fields[name].touched && this.fields[name].valid,  \'has-helper\': helper, \'stacked\': stacked }">\n' + '        <div :class="{\'col-sm-4\': !stacked}" v-if="label">\n' + '            <label class="control-label">{{ label }}: <span v-if="required">*</span></label>\n' + '            <p class="help-block" v-text="helper" v-if="helper"></p>\n' + '        </div>\n' + '        <div class="control-container" :class="{\'col-sm-8\': (!stacked && label)}">\n' + '            <div :class="{\'input-group\': usingAddons}">\n' + '                <div class="input-group-addon" v-if="slotExists(\'leftAddon\')">\n' + '                    <slot name="leftAddon"></slot>\n' + '                </div>\n' + '                <div class="input-group-btn" v-if="slotExists(\'leftBtn\')">\n' + '                    <slot name="leftBtn"></slot>\n' + '                </div>\n' + '               <div class="wrap-controller">' + '                   <input :type="type" v-on:input="updateValue($event.target.value)" v-on:blur="blur($event.target.value)" class="form-control" v-on:keyup.enter="enterKeyPressed"\n' + '                       :name="name" :id="id" :readonly="readonly" :value="value" :placeholder="placeholder" v-validate.touched :data-vv-rules="rules">\n' + '                </div>' + '                <div class="input-group-addon" v-if="slotExists(\'rightAddon\')">\n' + '                    <slot name="rightAddon"></slot>\n' + '                </div>\n' + '                <div class="input-group-btn" v-if="slotExists(\'rightBtn\')">\n' + '                    <slot name="rightBtn"></slot>\n' + '                </div>\n' + '            </div>\n' + '            <p class="text-danger" v-if="showError" v-text="errorMessage"></p>\n' + '            <p class="text-danger" v-if="this.errors.has(name)" v-text="this.errors.first(name)"></p>\n' + '        </div>\n' + '        <div class="clearfix"></div>\n' + '    </div>',
    props: {
        name: {
            type: String,
            required: true
        },
        label: String,
        helper: String,
        showError: {
            type: Boolean,
            default: false
        },
        placeholder: String,
        stacked: {
            type: Boolean,
            default: false
        },
        value: [String, Number],
        type: {
            type: String,
            default: function _default() {
                return 'text';
            }
        },
        required: {
            type: Boolean,
            default: false
        },
        readonly: {
            type: Boolean,
            default: false
        },
        id: String,
        errorMessage: String,
        rules: String
    },
    watch: {
        value: function value(_value) {
            this.$validator.validateAll();
        }
    },
    computed: {
        usingAddons: function usingAddons() {
            return !(Object.keys(this.$slots).length === 0 && this.$slots.constructor === Object);
        }
    },
    methods: {
        enterKeyPressed: function enterKeyPressed() {
            this.$emit('enter');
        },
        updateValue: function updateValue(value) {
            this.$emit('input', value);
        },
        blur: function blur(value) {
            this.$emit('blur', value);
        },
        slotExists: function slotExists(name) {
            return name in this.$slots;
        }
    }

});
'use strict';

Vue.component('list-box', {
    template: '<div class="form-group" :class="{\'has-error\': this.fields[name].touched && this.fields[name].invalid, \'has-success\': this.fields[name].touched && this.fields[name].valid,  \'has-helper\': helper, \'stacked\': stacked }">' + '        <div :class="{\'col-sm-4\': !stacked}" v-if="label">' + '            <label class="control-label">{{ label }}: <span v-if="required">*</span></label>' + '            <p class="help-block" v-text="helper" v-if="helper"></p>' + '        </div>' + '        <div class="control-container" :class="{\'col-sm-8\': (!stacked && label)}">' + '            <div :class="{\'input-group\': usingAddons}">' + '                <div class="input-group-addon" v-if="slotExists(\'leftAddon\')">' + '                    <slot name="leftAddon"></slot>' + '                </div>' + '                <div class="input-group-btn" v-if="slotExists(\'leftBtn\')">' + '                    <slot name="leftBtn"></slot>' + '                </div>' + '<div class="wrap-controller">' + '                <select :name="name" :id="name" class="form-control" v-on:change="updateValue($event.target.value)" v-validate :data-vv-rules="rules">' + '                    <option value="" readonly v-text="placeholder" v-if="placeholder"' + '                            :selected="value == null || value == \'\'"></option>' + '                    <option v-if="!keyName && !keyValue" v-for="option in options" :value="option" v-text="option"' + '                            :selected="option == value"></option>' + '                    <option v-if="keyName && keyValue" v-for="option in options" :value="option[keyValue]" v-text="option[keyName]"' + '                            :selected="option[keyValue] == value"></option>' + '                </select>' + '</div>' + '                <div class="input-group-addon" v-if="slotExists(\'rightAddon\')">' + '                    <slot name="rightAddon"></slot>' + '                </div>' + '                <div class="input-group-btn" v-if="slotExists(\'rightBtn\')">' + '                    <slot name="rightBtn"></slot>' + '                </div>' + '            </div>' + '            <p class="text-danger" v-if="showError" v-text="errorMessage"></p>' + '            <p class="text-danger" v-if="this.errors.has(name)" v-text="this.errors.first(name)"></p>' + '        </div>' + '        <div class="clearfix"></div>' + '    </div>',
    props: {
        name: {
            type: String,
            required: true
        },
        label: {
            type: String
        },
        options: {
            // type: Array,
            required: true
        },
        keyName: String,
        keyValue: String,
        labelName: {
            type: String,
            default: function _default() {
                return 'label';
            }
        },
        helper: String,
        showError: {
            type: Boolean,
            default: false
        },
        placeholder: String,
        stacked: {
            type: Boolean,
            default: false
        },
        value: {},
        required: {
            type: Boolean,
            default: false
        },
        errorMessage: String,
        rules: String
    },
    methods: {
        slotExists: function slotExists(name) {
            return name in this.$slots;
        },
        updateValue: function updateValue(value) {
            this.$emit('input', value);
        }
    },
    computed: {
        usingAddons: function usingAddons() {
            return !(Object.keys(this.$slots).length === 0 && this.$slots.constructor === Object);
        }
    },
    updated: function updated() {
        if (this.options.length) {
            var element = document.getElementById(this.name);
            if (element.options[element.selectedIndex]) {
                this.updateValue(element.options[element.selectedIndex].value);
            }
        }
    }
});
'use strict';

Vue.component('switch-check', {
    template: '<div class="form-group switch-group" :class="{\'has-error\': this.fields[name].touched && this.fields[name].invalid, \'has-success\': this.fields[name].touched && this.fields[name].valid,  \'has-helper\': helper, \'stacked\': stacked }">' + '        <div :class="{\'col-sm-4\': ! stacked}" v-if="label">' + '            <label class="control-label" :for="id">{{ label }}</label>' + '            <p class="help-block" v-if="helper">{{ helper }}</p>' + '        </div>' + '        <div :class="{\'col-sm-8\': ! stacked  }">' + '            <label class="switch-component">' + '                <div class="wrap-controller">' + '                    <input type="checkbox" :id="id" :name="name" :checked="checked" v-on:change="updateValue($event.target.value)" :class="{\'has-error\': this.errors.has(name)}">' + '                </div>' + '                <div class="slider round">' + '                    <span class="yes-label" v-if="labels">Yes</span>' + '                    <span class="no-label" v-if="labels">No</span>' + '                </div>' + '            </label>' + '        </div>' + '    </div>',
    model: {
        prop: 'checked',
        event: 'change'
    },
    props: {
        name: {
            type: String,
            required: true
        },
        labels: {
            type: Boolean,
            default: false
        },
        label: {
            type: String
        },
        stacked: Boolean,
        helper: String,
        id: String,
        checked: Boolean,
        labelColumn: {
            type: String,
            default: 'col-sm-2'
        },
        inputColumn: {
            type: String,
            default: 'col-sm-10'
        },
        type: {
            type: String,
            default: 'checkbox'
        }
    },
    methods: {
        updateValue: function updateValue(value) {
            this.$emit('change', value);
        }
    }
});
'use strict';

Vue.component('switch-radio', {
    template: '<div class="form-group switch-group" :class="{\'has-error\': this.fields[name].touched && this.fields[name].invalid, \'has-success\': this.fields[name].touched && this.fields[name].valid,  \'has-helper\': helper, \'stacked\': stacked }">' + '        <div :class="{\'col-sm-4\': ! stacked}" v-if="label">' + '            <label class="control-label" :for="id">{{ label }}</label>' + '            <p class="help-block" v-if="helper">{{ helper }}</p>' + '        </div>' + '        <div :class="{\'col-sm-8\': ! stacked  }">' + '            <label class="switch-component">' + '                <input :value="value" type="radio" :id="id" :name="name" :checked="checked" v-on:change="updateValue($event.target.value)" v-validate :data-vv-rules="rules">' + '                <div class="slider round">' + '                    <span class="yes-label" v-if="labels">Yes</span>' + '                    <span class="no-label" v-if="labels">No</span>' + '                </div>' + '            </label>' + '            <p class="text-danger" v-if="this.errors.has(name)" v-text="this.errors.first(name)"></p>' + '        </div>' + '    </div>',
    model: {
        prop: 'checked',
        event: 'change'
    },
    props: {
        name: {
            type: String,
            required: true
        },
        labels: {
            type: Boolean,
            default: false
        },
        label: {
            type: String
        },
        stacked: Boolean,
        helper: String,
        id: String,
        checked: {},
        labelColumn: {
            type: String,
            default: 'col-sm-2'
        },
        inputColumn: {
            type: String,
            default: 'col-sm-10'
        },
        type: {
            type: String,
            default: 'checkbox'
        },
        value: {},
        rules: String
    },
    methods: {
        updateValue: function updateValue(value) {
            this.$emit('change', value);
        }
    }
});
'use strict';

Vue.component('textarea-box', {
    template: ' <div class="form-group" :class="{\'has-error\': this.fields[name].touched && this.fields[name].invalid, \'has-success\': this.fields[name].touched && this.fields[name].valid,  \'has-helper\': helper, \'stacked\': stacked }">\n' + '        <div :class="{\'col-sm-4\': !stacked}" v-if="label">\n' + '            <label class="control-label">{{ label }}: <span v-if="required">*</span></label>\n' + '            <p class="help-block" v-text="helper" v-if="helper"></p>\n' + '        </div>\n' + '        <div class="control-container" :class="{\'col-sm-8\': !stacked}">\n' + '            <textarea v-validate.initial :data-vv-rules="rules" :name="name" id="name" rows="5" v-on:input="updateValue($event.target.value)"\n' + '                      :value="value" class="form-control"></textarea>\n' + '            <p class="text-danger" v-if="showError" v-text="errorMessage"></p>\n' + '            <p class="text-danger" v-if="this.errors.has(name)" v-text="this.errors.first(name)"></p>\n' + '        </div>\n' + '        <div class="clearfix"></div>\n' + '    </div>',
    props: {
        name: {
            type: String,
            required: true
        },
        label: {
            type: String
        },
        helper: String,
        showError: {
            type: Boolean,
            default: false
        },
        stacked: {
            type: Boolean,
            default: false
        },
        value: [String],
        required: {
            type: Boolean,
            default: false
        },
        id: String,
        errorMessage: String,
        rules: String
    },
    methods: {
        updateValue: function updateValue(value) {
            this.$emit('input', value);
        }
    }
});
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Contact = function () {
    function Contact(lastName, firstName, gender, age) {
        _classCallCheck(this, Contact);

        this.lastName = lastName;
        this.firstName = firstName;
        this.gender = gender;
        this.age = age;
    }

    _createClass(Contact, [{
        key: 'empty',
        value: function empty() {
            if (this.fieldEmpty('lastName') || this.fieldEmpty('firstName') || this.fieldEmpty('gender') || this.fieldEmpty('age')) {
                return true;
            }
            return false;
        }
    }, {
        key: 'fieldEmpty',
        value: function fieldEmpty(name) {
            if (this[name] === null || this[name] === undefined || this[name] === "" || this[name] === 0) return true;else return false;
        }
    }]);

    return Contact;
}();